#pragma kernel DefferedShading
#pragma multi_compile __ CLUSTER_LIGHT
#include "Assets/GreeningRenderPipeline/ShaderLibrary/GreeningRP_GBuffer.hlsl"
#include "Assets/GreeningRenderPipeline/ShaderLibrary/GreeningRP_Brdf.hlsl"
#include "Assets/GreeningRenderPipeline/ShaderLibrary/GreeningRP_Lighting.hlsl"
#include "Assets/GreeningRenderPipeline/ShaderLibrary/GreeningRP_ClusterLight.hlsl"


RWTexture2D<float4> DefferedShading_Dest;
// #if defined CLUSTER_LIGHT
RWStructuredBuffer<uint2> ValidLightIndex_Buffer;
int NumClusterX;
int NumClusterY;
int NumClusterZ;
bool UseClusterLight;
// #endif

Texture2D GBuffer0;
Texture2D GBuffer1;
Texture2D GBuffer2;
Texture2D SceneDepth;

int Index3DTo1D(int3 id3){
    return id3.z*NumClusterX*NumClusterY+id3.y*NumClusterX+id3.x;
}
int3 GetCluster(float3 NdcPos){
    float3 Pos;
    Pos.xy=NdcPos.xy;
    Pos.z=LinearEyeDepth(NdcPos.z);
    Pos.z=(Pos.z-NearClipPlane)/(FarClipPlane-NearClipPlane);
    Pos*=float3(NumClusterX,NumClusterY,NumClusterZ);
    int3 id=(int3)floor(Pos);
    return id;
}

void DecodeGBuffer(int2 id,out float Roughness,out float Metallic,out float3 BaseColor,out float3 NormalWS,out float Occlusion){
    float4 GBuffer0_Data=GBuffer0.Load(int3(id.xy,0)).xyzw;
    float4 GBuffer1_Data=GBuffer1.Load(int3(id.xy,0)).xyzw;
    float4 GBuffer2_Data=GBuffer2.Load(int3(id.xy,0)).xyzw;
    BaseColor=GBuffer0_Data.xyz;
    Occlusion=GBuffer0_Data.w;
    Roughness=GBuffer2_Data.x;
    Metallic=GBuffer2_Data.y;
    NormalWS=UnpackNormal(GBuffer1_Data.xyz);
}



[numthreads(8,8,1)]
void DefferedShading (uint3 id : SV_DispatchThreadID)
{
    float2 uv=id.xy*ScreenParams.xy;
    float NdcDepth=SceneDepth.Load(int3(id.xy,0)).x;
    [branch]
    if(NdcDepth==0.0f){
        DefferedShading_Dest[id.xy] = (0.0f).xxxx;
        return;
    }
    float3 BaseColor,NormalWS;
    float Occlusion,Roughness,Metallic;
    DecodeGBuffer(id.xy,Roughness,Metallic,BaseColor,NormalWS,Occlusion);
    
    float3 PositionWS=GetPositionWS(uv,NdcDepth);
    float3 ViewDirWS=normalize(_WorldSpaceCameraPos-PositionWS);
    
    float3 FinalColor=0;
    //处理方向光
    [branch]
    if(IsAnyDirectionalLight){
        [loop]
        for(int i=0;i<DirectionalLightCount;i++){
            float3 LightDir=GetDirectionalLight_Direction(i);
            float3 LightColor=GetDirectionalLight_Color(i);
            BxDFContext Context=BxDFContext_Init(NormalWS,ViewDirWS,LightDir);
            FinalColor+=LightColor*Brdf_Diffuse_Specular(BaseColor,Roughness,Metallic,Context).xyz;
        }
    }

    //处理点光
    #if defined CLUSTER_LIGHT
    int3 Cluster_Id=GetCurCluster(uv,NdcDepth,NumClusterX,NumClusterY,NumClusterZ);
    int Cluster_Id_1D=Index3DTo1D(Cluster_Id);
    int4 Decode_1=Decodeuint32To4Byte(ValidLightIndex_Buffer[Cluster_Id_1D].x);
    int4 Decode_2=Decodeuint32To4Byte(ValidLightIndex_Buffer[Cluster_Id_1D].y);
    int LightIndex[8];
    LightIndex[0]=Decode_1.x;
    LightIndex[1]=Decode_1.y;
    LightIndex[2]=Decode_1.z;
    LightIndex[3]=Decode_1.w;
    LightIndex[4]=Decode_2.x;
    LightIndex[5]=Decode_2.y;
    LightIndex[6]=Decode_2.z;
    LightIndex[7]=Decode_2.w;
    [branch]
    if(IsAnyPointLight){
        [loop]
        for(int j=0;j<8;j++){
            [branch]
            if(LightIndex[j]!=0){
                float3 LightDir=GetPointLight_Direction(LightIndex[j]-1,PositionWS);
                float3 LightColor=GetPointLight_Color(LightIndex[j]-1);
                float DistanceAttenuation=GetPointLight_DistanceAttenuation(LightIndex[j]-1,PositionWS);
                BxDFContext Context=BxDFContext_Init(NormalWS,ViewDirWS,LightDir);
                FinalColor+=DistanceAttenuation*LightColor*Brdf_Diffuse_Specular(BaseColor,Roughness,Metallic,Context).xyz;
            }
        }
    }
    #else
    [branch]
    if(IsAnyPointLight){
        [loop]
        for(int j=0;j<PointLightCount;j++){
            [branch]
            float3 LightDir=GetPointLight_Direction(j,PositionWS);
            float3 LightColor=GetPointLight_Color(j);
            float DistanceAttenuation=GetPointLight_DistanceAttenuation(j,PositionWS);
            BxDFContext Context=BxDFContext_Init(NormalWS,ViewDirWS,LightDir);
            FinalColor+=DistanceAttenuation*LightColor*Brdf_Diffuse_Specular(BaseColor,Roughness,Metallic,Context).xyz;
        }
    }
    #endif
    
    DefferedShading_Dest[id.xy] = FinalColor.xyzz;
}
